(defun qsort (l . f)
  (quicksort l 0 (- (length l) 1) (if f (car f) (lambda (x) x))))

(defun quicksort (l left right f)
  (if (< left right)
    (let* ((return-value (partition l left right f))
           (pivot (car return-value))
           (items (cadr return-value)))
      (quicksort (quicksort items left (- pivot 1) f)
                 (+ pivot 1) right f))
    l))

(defun partition (l left right f)
  (let* ((return-value (partition-inner l left left right f))
         (store (car return-value))
         (items (cadr return-value)))
    (list store (swap items store right))))

(defun partition-inner (l index store right f)
  (if (< index right)
    (if (<= (f (list-ref l index)) (f (list-ref l right)))
      (partition-inner (swap l index store) (+ index 1) (+ store 1) right f)
      (partition-inner l (+ index 1) store right f))
    (list store l)))

(defun swap (l index1 index2)
  (let ((item1 (list-ref l index1))
        (item2 (list-ref l index2)))
    (replace (replace l index1 item2) index2 item1)))

(defun replace (l index item)
  (cond ((null l) '())
        ((zerop index) (cons item (cdr l)))
        (t (cons (car l) (replace (cdr l) (- index 1) item)))))
